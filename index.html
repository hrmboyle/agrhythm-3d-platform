<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgRhythm Platform - 3D Structure Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        #info h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #64f4ff;
        }
        
        #info p {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 10px;
        }
        
        .controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .controls h3 {
            font-size: 16px;
            margin-bottom: 8px;
            color: #64f4ff;
        }
        
        .controls p {
            font-size: 12px;
            margin: 5px 0;
        }
        
        #node-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            display: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 244, 255, 0.3);
        }
        
        #node-info h3 {
            color: #64f4ff;
            margin-bottom: 10px;
        }
        
        #node-info p {
            font-size: 13px;
            margin: 5px 0;
        }
        
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .legend h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #64f4ff;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 12px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        #visualization-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
        
        #edit-controls {
            position: absolute;
            top: 80px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .edit-button {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 165, 0, 0.5);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            font-size: 12px;
        }
        
        .edit-button:hover {
            background: rgba(255, 165, 0, 0.2);
            transform: scale(1.05);
        }
        
        .edit-button.active {
            background: rgba(255, 165, 0, 0.3);
            border-color: #ffa500;
        }
        
        /* Node Editor Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: rgba(20, 20, 20, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #64f4ff;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(100, 244, 255, 0.3);
            padding-bottom: 15px;
        }
        
        .modal-header h2 {
            color: #64f4ff;
            margin: 0;
        }
        
        .close-button {
            background: none;
            border: none;
            color: #ff6b6b;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background 0.3s;
        }
        
        .close-button:hover {
            background: rgba(255, 107, 107, 0.2);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #64f4ff;
            font-weight: bold;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(100, 244, 255, 0.3);
            border-radius: 5px;
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        .form-group textarea {
            height: 80px;
            resize: vertical;
        }
        
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #64f4ff;
            box-shadow: 0 0 5px rgba(100, 244, 255, 0.5);
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid rgba(100, 244, 255, 0.3);
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .btn-primary {
            background: #64f4ff;
            color: #000;
        }
        
        .btn-primary:hover {
            background: #4dd5e8;
            transform: scale(1.05);
        }
        
        .btn-danger {
            background: #ff6b6b;
            color: white;
        }
        
        .btn-danger:hover {
            background: #ff5252;
            transform: scale(1.05);
        }
        
        .btn-secondary {
            background: rgba(100, 100, 100, 0.7);
            color: white;
        }
        
        .btn-secondary:hover {
            background: rgba(100, 100, 100, 0.9);
        }
        
        /* Edit mode indicators */
        .edit-mode-active {
            cursor: pointer !important;
        }
        
        .edit-mode-active canvas {
            cursor: crosshair !important;
        }
        
        .connection-preview {
            pointer-events: none;
        }
        
        .viz-button {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(100, 244, 255, 0.5);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .viz-button:hover {
            background: rgba(100, 244, 255, 0.2);
            transform: scale(1.05);
        }
        
        .viz-button.active {
            background: rgba(100, 244, 255, 0.3);
            border-color: #64f4ff;
        }
        
        /* 2D JSON Visualization */
        #json2d-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: none;
            overflow: hidden;
        }
        
        #json2d-canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #json2d-canvas:active {
            cursor: grabbing;
        }
        
        .json2d-node {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #64f4ff;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .json2d-node:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 16px rgba(100, 244, 255, 0.5);
            border-color: #ffa500;
        }
        
        .json2d-node.selected {
            background: rgba(100, 244, 255, 0.9);
            color: #000;
        }
        
        .json2d-connection {
            position: absolute;
            background: #64f4ff;
            z-index: 1;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- 2D JSON Visualization Container -->
    <div id="json2d-container">
        <svg id="json2d-canvas" width="100%" height="100%"></svg>
    </div>
    
    <div id="info">
        <h1>AgRhythm Platform</h1>
        <p>Interactive 3D visualization of website structure</p>
        <p>Nodes represent different pages and components. Lines show connections and data flow.</p>
        
        <div class="controls">
            <h3>Controls:</h3>
            <p>üñ±Ô∏è <strong>Left Click + Drag:</strong> Rotate</p>
            <p>üñ±Ô∏è <strong>Right Click + Drag:</strong> Pan</p>
            <p>üñ±Ô∏è <strong>Scroll:</strong> Zoom</p>
            <p>üñ±Ô∏è <strong>Hover:</strong> Highlight connections</p>
            <p>üñ±Ô∏è <strong>Click Node:</strong> Show details</p>
            <div id="edit-controls-info" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3);">
                <h4>Edit Mode:</h4>
                <p>üñòÔ∏è <strong>Click Node:</strong> Edit properties</p>
                <p>‚ûï <strong>Add Node Button:</strong> Create new node</p>
                <p>üñòÔ∏è <strong>Double-click Space:</strong> Create node at cursor</p>
                <p>üñòÔ∏è <strong>Shift + Click Node:</strong> Start connection</p>
                <p>üñòÔ∏è <strong>Right-click:</strong> Cancel connection</p>
            </div>
        </div>
    </div>
    
    <div id="visualization-toggle">
        <button class="viz-button active" onclick="switchVisualization('hierarchical')">3D Hierarchical</button>
        <button class="viz-button" onclick="switchVisualization('json2d')">üìä 2D JSON Graph</button>
    </div>
    
    <div id="edit-controls">
        <button class="edit-button" id="edit-mode-toggle" onclick="toggleEditMode()">üîß Edit Mode</button>
        <button class="edit-button" id="add-node" onclick="showAddNodeDialog()" style="display: none;">‚ûï Add Node</button>
        <button class="edit-button" id="save-data" onclick="saveData()" style="display: none;">üíæ Save</button>
        <button class="edit-button" id="load-data" onclick="loadData()" style="display: none;">üìÅ Load</button>
        <button class="edit-button" id="export-data" onclick="exportData()" style="display: none;">üì§ Export</button>
    </div>
    
    <div class="legend">
        <h3>Node Types</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b6b;"></div>
            <span>Entry/Login Pages</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #4ecdc4;"></div>
            <span>Core Platform</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #45b7d1;"></div>
            <span>Dashboard Sections</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f7dc6f;"></div>
            <span>Operators/Specialists</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #bb8fce;"></div>
            <span>External Systems</span>
        </div>
    </div>
    
    <div id="node-info">
        <h3 id="node-title">Node Information</h3>
        <p id="node-type"></p>
        <p id="node-connections"></p>
        <p id="node-details"></p>
    </div>
    
    <!-- Node Editor Modal -->
    <div class="modal-overlay" id="node-editor-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Edit Node</h2>
                <button class="close-button" onclick="closeNodeEditor()">&times;</button>
            </div>
            
            <form id="node-editor-form">
                <div class="form-group">
                    <label for="node-label">Label:</label>
                    <input type="text" id="node-label" name="label" placeholder="Enter node label">
                </div>
                
                <div class="form-group">
                    <label for="node-type">Type:</label>
                    <select id="node-type-select" name="type">
                        <option value="entry">Entry/Login</option>
                        <option value="hub">Hub</option>
                        <option value="component">Component</option>
                        <option value="section">Section</option>
                        <option value="data">Data</option>
                        <option value="integration">Integration</option>
                        <option value="external">External</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="node-group">Group:</label>
                    <select id="node-group-select" name="group">
                        <option value="entry">Entry</option>
                        <option value="core">Core</option>
                        <option value="dashboard">Dashboard</option>
                        <option value="operators">Operators</option>
                        <option value="farmer">Farmer</option>
                        <option value="external">External</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="node-notes">Notes:</label>
                    <textarea id="node-notes" name="notes" placeholder="Add notes about this node..."></textarea>
                </div>
                
                <div class="form-group">
                    <label for="node-description">Description:</label>
                    <textarea id="node-description" name="description" placeholder="Detailed description of this node's function..."></textarea>
                </div>
            </form>
            
            <div class="button-group">
                <button type="button" class="btn btn-danger" id="delete-node-btn" onclick="deleteCurrentNode()">Delete Node</button>
                <button type="button" class="btn btn-secondary" onclick="closeNodeEditor()">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="saveNodeChanges()">Save Changes</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Website structure data
        const siteData = {
            nodes: [
                // Entry points
                { id: 'profile-edit', label: 'Profile/Edit', type: 'entry', group: 'entry' },
                { id: 'billing', label: 'Billing', type: 'entry', group: 'entry' },
                
                // Core
                { id: 'agrhythm', label: 'AgRhythm Hub', type: 'hub', group: 'core' },
                { id: 'dashboard', label: 'Dashboard', type: 'component', group: 'core' },
                { id: 'ai-chat', label: 'AI Chat', type: 'component', group: 'core' },
                { id: 'insights', label: 'Insights', type: 'component', group: 'core' },
                { id: 'collected-data', label: 'Collected Data', type: 'data', group: 'core' },
                
                // Dashboard sections
                { id: 'reports', label: 'Reports', type: 'section', group: 'dashboard' },
                { id: 'audits', label: 'Audits', type: 'section', group: 'dashboard' },
                { id: 'maps', label: 'Maps', type: 'section', group: 'dashboard' },
                { id: 'crops', label: 'Crops', type: 'section', group: 'dashboard' },
                { id: 'infrastructure', label: 'Infrastructure', type: 'section', group: 'dashboard' },
                { id: 'health-safety', label: 'Health & Safety', type: 'section', group: 'dashboard' },
                { id: 'stock', label: 'Stock', type: 'section', group: 'dashboard' },
                { id: 'tasks', label: 'Tasks/Todo', type: 'section', group: 'dashboard' },
                { id: 'finances', label: 'Finances', type: 'section', group: 'dashboard' },
                
                // Operators
                { id: 'operator-login', label: 'Operator Login', type: 'login', group: 'operators' },
                { id: 'drone-operators', label: 'Drone Operators', type: 'section', group: 'operators' },
                { id: 'other-specialists', label: 'Other Specialists', type: 'section', group: 'operators' },
                
                // Farmer
                { id: 'farmer-login', label: 'Farmer Login', type: 'login', group: 'farmer' },
                { id: 'referrals', label: 'Referrals', type: 'section', group: 'farmer' },
                { id: 'companies', label: 'Companies', type: 'component', group: 'farmer' },
                { id: 'products', label: 'Products', type: 'component', group: 'farmer' },
                
                // External
                { id: 'api-access', label: 'API Access', type: 'integration', group: 'external' },
                { id: 'cameras', label: 'Cameras', type: 'external', group: 'external' },
                { id: 'gallagher', label: 'Gallagher', type: 'external', group: 'external' },
                { id: 'iot', label: 'IOT Devices', type: 'external', group: 'external' },
                { id: 'necklaces', label: 'Necklaces', type: 'external', group: 'external' }
            ],
            links: [
                // Entry connections
                { source: 'profile-edit', target: 'billing' },
                { source: 'billing', target: 'agrhythm' },
                { source: 'profile-edit', target: 'agrhythm' },
                
                // Core connections
                { source: 'agrhythm', target: 'dashboard' },
                { source: 'dashboard', target: 'reports' },
                { source: 'dashboard', target: 'audits' },
                { source: 'dashboard', target: 'maps' },
                { source: 'dashboard', target: 'crops' },
                { source: 'dashboard', target: 'infrastructure' },
                { source: 'dashboard', target: 'health-safety' },
                { source: 'dashboard', target: 'stock' },
                { source: 'dashboard', target: 'tasks' },
                { source: 'dashboard', target: 'finances' },
                
                // AI and Data flow
                { source: 'collected-data', target: 'ai-chat' },
                { source: 'agrhythm', target: 'ai-chat' },
                { source: 'agrhythm', target: 'insights' },
                { source: 'insights', target: 'farmer-login' },
                
                // Operator flow
                { source: 'agrhythm', target: 'operator-login' },
                { source: 'operator-login', target: 'drone-operators' },
                { source: 'operator-login', target: 'other-specialists' },
                { source: 'reports', target: 'drone-operators' },
                
                // Farmer flow
                { source: 'farmer-login', target: 'referrals' },
                { source: 'referrals', target: 'companies' },
                { source: 'referrals', target: 'products' },
                
                // API connections
                { source: 'agrhythm', target: 'api-access' },
                { source: 'api-access', target: 'cameras' },
                { source: 'api-access', target: 'gallagher' },
                { source: 'api-access', target: 'iot' },
                { source: 'api-access', target: 'necklaces' },
                { source: 'api-access', target: 'collected-data' }
            ]
        };

        // Three.js setup
        let scene, camera, renderer, controls;
        let nodes = [], links = [];
        let raycaster, mouse;
        let selectedNode = null;
        let hoveredNode = null;
        let currentLayout = 'hierarchical';
        
        // Control variables
        let isMouseDown = false;
        let mouseButton = 0;
        let startX = 0, startY = 0;
        let cameraDistance = 100;
        let theta = 0, phi = 0;
        
        // Edit mode variables
        let isEditMode = false;
        let currentEditingNode = null;
        let isCreatingConnection = false;
        let connectionSource = null;
        let connectionPreview = null;
        let nextNodeId = 1000; // Start from 1000 for new nodes
        
        // Node color mapping
        const nodeColors = {
            entry: 0xff6b6b,
            hub: 0x4ecdc4,
            component: 0x4ecdc4,
            data: 0x4ecdc4,
            section: 0x45b7d1,
            login: 0xff6b6b,
            integration: 0xbb8fce,
            external: 0xbb8fce
        };
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 100, 300);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 100);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(50, 50, 50);
            scene.add(pointLight);
            
            const pointLight2 = new THREE.PointLight(0x64f4ff, 0.4);
            pointLight2.position.set(-50, -50, -50);
            scene.add(pointLight2);
            
            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Create visualization
            createNodes();
            createLinks();
            applyHierarchicalLayout();
            
            // Add mouse controls
            setupControls();
            
            // Start animation
            animate();
        }
        
        function createNodes() {
            const nodeGeometry = new THREE.SphereGeometry(2, 32, 32);
            
            siteData.nodes.forEach((nodeData, index) => {
                const material = new THREE.MeshPhongMaterial({
                    color: nodeColors[nodeData.type] || 0xffffff,
                    emissive: nodeColors[nodeData.type] || 0xffffff,
                    emissiveIntensity: 0.2,
                    shininess: 100
                });
                
                const nodeMesh = new THREE.Mesh(nodeGeometry, material);
                nodeMesh.userData = nodeData;
                
                // Create label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'white';
                context.font = '24px Arial';
                context.textAlign = 'center';
                context.fillText(nodeData.label, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.8
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(10, 2.5, 1);
                sprite.position.y = -4;
                nodeMesh.add(sprite);
                
                scene.add(nodeMesh);
                nodes.push(nodeMesh);
            });
        }
        
        function createLinks() {
            const linkMaterial = new THREE.LineBasicMaterial({ 
                color: 0x64f4ff, 
                transparent: true, 
                opacity: 0.8,
                linewidth: 8 // Much thicker
            });
            
            siteData.links.forEach(linkData => {
                const sourceNode = nodes.find(n => n.userData.id === linkData.source);
                const targetNode = nodes.find(n => n.userData.id === linkData.target);
                
                if (sourceNode && targetNode) {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(6);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    
                    // Create multiple parallel lines for thickness effect
                    const linkGroup = new THREE.Group();
                    
                    // Main line
                    const mainLine = new THREE.Line(geometry.clone(), linkMaterial.clone());
                    linkGroup.add(mainLine);
                    
                    // Add slightly offset parallel lines for thickness
                    for (let i = 0; i < 3; i++) {
                        const offsetLine = new THREE.Line(geometry.clone(), linkMaterial.clone());
                        const offset = (i + 1) * 0.02;
                        offsetLine.position.set(offset, offset * 0.5, offset * 0.3);
                        linkGroup.add(offsetLine);
                    }
                    
                    linkGroup.userData = { source: sourceNode, target: targetNode, isLink: true };
                    scene.add(linkGroup);
                    links.push(linkGroup);
                }
            });
        }
        
        
        function applyHierarchicalLayout() {
            const levels = {
                'profile-edit': 0, 'billing': 0,
                'agrhythm': 1,
                'dashboard': 2, 'ai-chat': 2, 'insights': 2, 'collected-data': 2,
                'reports': 3, 'audits': 3, 'maps': 3, 'crops': 3, 'infrastructure': 3,
                'health-safety': 3, 'stock': 3, 'tasks': 3, 'finances': 3,
                'operator-login': 3, 'farmer-login': 3, 'api-access': 3,
                'drone-operators': 4, 'other-specialists': 4, 'referrals': 4,
                'cameras': 4, 'gallagher': 4, 'iot': 4, 'necklaces': 4,
                'companies': 5, 'products': 5
            };
            
            const levelCounts = {};
            Object.values(levels).forEach(level => {
                levelCounts[level] = (levelCounts[level] || 0) + 1;
            });
            
            const levelIndices = {};
            
            nodes.forEach(node => {
                const level = levels[node.userData.id] || 0;
                levelIndices[level] = (levelIndices[level] || 0) + 1;
                
                const xSpacing = 100 / (levelCounts[level] + 1);
                node.position.x = (levelIndices[level] * xSpacing) - 50;
                node.position.y = 40 - (level * 15);
                node.position.z = (Math.random() - 0.5) * 20;
            });
        }
        
        
        function switchVisualization(type) {
            currentLayout = type;
            
            // Update button states
            document.querySelectorAll('.viz-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            const canvasContainer = document.getElementById('canvas-container');
            const json2dContainer = document.getElementById('json2d-container');
            
            // Show/hide containers based on view type
            if (type === 'json2d') {
                canvasContainer.style.display = 'none';
                json2dContainer.style.display = 'block';
                initJSON2DVisualization();
            } else {
                canvasContainer.style.display = 'block';
                json2dContainer.style.display = 'none';
                
                // Apply 3D layout - only hierarchical now
                applyHierarchicalLayout();
            }
        }
        
        // 2D JSON Visualization Functions
        let svg2d = null;
        let json2dNodes = [];
        let json2dScale = 1;
        let json2dPanX = 0;
        let json2dPanY = 0;
        
        function initJSON2DVisualization() {
            const svg = document.getElementById('json2d-canvas');
            svg.innerHTML = ''; // Clear existing content
            
            // Convert siteData to JSON format for visualization
            const jsonData = {
                nodes: siteData.nodes.map(node => ({
                    id: node.id,
                    label: node.label,
                    type: node.type,
                    group: node.group,
                    description: node.description || '',
                    notes: node.notes || ''
                })),
                links: siteData.links
            };
            
            // Create 2D graph visualization
            render2DJsonGraph(jsonData, svg);
            
            // Add pan and zoom functionality
            setup2DControls(svg);
        }
        
        function render2DJsonGraph(data, svg) {
            const width = svg.clientWidth || window.innerWidth;
            const height = svg.clientHeight || window.innerHeight;
            
            // Create main group for all elements
            const mainGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            mainGroup.id = 'main-group';
            svg.appendChild(mainGroup);
            
            // Position nodes in a hierarchical tree layout
            const positionedNodes = calculate2DPositions(data.nodes, data.links, width, height);
            
            // Render connections first (so they appear behind nodes)
            renderConnections(data.links, positionedNodes, mainGroup);
            
            // Render nodes
            renderNodes(positionedNodes, mainGroup);
            
            json2dNodes = positionedNodes;
        }
        
        function calculate2DPositions(nodes, links, width, height) {
            const positioned = nodes.map(node => ({ ...node }));
            const nodeMap = new Map();
            positioned.forEach(node => nodeMap.set(node.id, node));
            
            // Create adjacency list
            const adjacencyList = new Map();
            positioned.forEach(node => adjacencyList.set(node.id, []));
            
            links.forEach(link => {
                if (adjacencyList.has(link.source)) {
                    adjacencyList.get(link.source).push(link.target);
                }
            });
            
            // Find root node (AgRhythm hub or first node)
            const rootNode = positioned.find(n => n.id === 'agrhythm') || positioned[0];
            if (!rootNode) return positioned;
            
            // BFS to assign levels and positions
            const visited = new Set();
            const queue = [{ node: rootNode, level: 0, index: 0 }];
            const levels = new Map();
            
            visited.add(rootNode.id);
            
            while (queue.length > 0) {
                const { node, level, index } = queue.shift();
                
                if (!levels.has(level)) {
                    levels.set(level, []);
                }
                levels.get(level).push(node);
                
                // Add children to queue
                const children = adjacencyList.get(node.id) || [];
                children.forEach((childId, childIndex) => {
                    if (!visited.has(childId) && nodeMap.has(childId)) {
                        visited.add(childId);
                        queue.push({ node: nodeMap.get(childId), level: level + 1, index: childIndex });
                    }
                });
            }
            
            // Add unvisited nodes to the last level
            positioned.forEach(node => {
                if (!visited.has(node.id)) {
                    const lastLevel = Math.max(...levels.keys(), 0) + 1;
                    if (!levels.has(lastLevel)) {
                        levels.set(lastLevel, []);
                    }
                    levels.get(lastLevel).push(node);
                }
            });
            
            // Position nodes based on their level
            const levelHeight = height / (levels.size + 1);
            
            levels.forEach((levelNodes, level) => {
                const levelWidth = width / (levelNodes.length + 1);
                levelNodes.forEach((node, index) => {
                    node.x = (index + 1) * levelWidth;
                    node.y = (level + 1) * levelHeight;
                });
            });
            
            return positioned;
        }
        
        function renderNodes(nodes, parent) {
            nodes.forEach(node => {
                // Create node group
                const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                nodeGroup.setAttribute('class', 'json2d-node-group');
                nodeGroup.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                
                // Create node rectangle
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('width', '120');
                rect.setAttribute('height', '60');
                rect.setAttribute('x', '-60');
                rect.setAttribute('y', '-30');
                rect.setAttribute('rx', '8');
                rect.setAttribute('fill', getNodeColor2D(node.type));
                rect.setAttribute('stroke', '#64f4ff');
                rect.setAttribute('stroke-width', '2');
                rect.setAttribute('class', 'json2d-node-rect');
                
                // Create node label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dy', '5');
                text.setAttribute('fill', '#333');
                text.setAttribute('font-size', '12');
                text.setAttribute('font-weight', 'bold');
                text.textContent = node.label.length > 12 ? node.label.substring(0, 12) + '...' : node.label;
                
                nodeGroup.appendChild(rect);
                nodeGroup.appendChild(text);
                parent.appendChild(nodeGroup);
                
                // Add hover and click events
                nodeGroup.addEventListener('mouseenter', () => {
                    rect.setAttribute('stroke', '#ffa500');
                    rect.setAttribute('stroke-width', '3');
                    nodeGroup.style.transform = `translate(${node.x}px, ${node.y}px) scale(1.1)`;
                });
                
                nodeGroup.addEventListener('mouseleave', () => {
                    rect.setAttribute('stroke', '#64f4ff');
                    rect.setAttribute('stroke-width', '2');
                    nodeGroup.style.transform = `translate(${node.x}px, ${node.y}px) scale(1)`;
                });
                
                nodeGroup.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handle2DNodeClick(node, e);
                });
                
                // Store node reference for easy access
                nodeGroup.userData = node;
            });
        }
        
        function renderConnections(links, nodes, parent) {
            const nodeMap = new Map();
            nodes.forEach(node => nodeMap.set(node.id, node));
            
            links.forEach(link => {
                const sourceNode = nodeMap.get(link.source);
                const targetNode = nodeMap.get(link.target);
                
                if (sourceNode && targetNode) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', sourceNode.x);
                    line.setAttribute('y1', sourceNode.y);
                    line.setAttribute('x2', targetNode.x);
                    line.setAttribute('y2', targetNode.y);
                    line.setAttribute('stroke', '#64f4ff');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('opacity', '0.6');
                    line.setAttribute('class', 'json2d-connection');
                    
                    parent.appendChild(line);
                }
            });
        }
        
        function getNodeColor2D(type) {
            const colors = {
                entry: 'rgba(255, 107, 107, 0.9)',
                hub: 'rgba(78, 205, 196, 0.9)',
                component: 'rgba(78, 205, 196, 0.9)',
                data: 'rgba(78, 205, 196, 0.9)',
                section: 'rgba(69, 183, 209, 0.9)',
                login: 'rgba(255, 107, 107, 0.9)',
                integration: 'rgba(187, 143, 206, 0.9)',
                external: 'rgba(187, 143, 206, 0.9)'
            };
            return colors[type] || 'rgba(255, 255, 255, 0.9)';
        }
        
        function setup2DControls(svg) {
            let isDragging = false;
            let startX, startY;
            
            svg.addEventListener('mousedown', (e) => {
                if (e.target === svg || e.target.id === 'main-group') {
                    isDragging = true;
                    startX = e.clientX - json2dPanX;
                    startY = e.clientY - json2dPanY;
                    svg.style.cursor = 'grabbing';
                }
            });
            
            svg.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    json2dPanX = e.clientX - startX;
                    json2dPanY = e.clientY - startY;
                    updateTransform();
                }
            });
            
            svg.addEventListener('mouseup', () => {
                isDragging = false;
                svg.style.cursor = 'grab';
            });
            
            svg.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
                json2dScale = Math.max(0.1, Math.min(3, json2dScale * scaleFactor));
                updateTransform();
            });
            
            // Add double-click for node creation in edit mode
            svg.addEventListener('dblclick', (e) => {
                if (isEditMode && (e.target === svg || e.target.id === 'main-group')) {
                    create2DNode(e.clientX, e.clientY);
                }
            });
            
            // Add right-click to cancel connection mode
            svg.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (is2DConnectionMode) {
                    cancel2DConnection();
                }
            });
            
            function updateTransform() {
                const mainGroup = svg.querySelector('#main-group');
                if (mainGroup) {
                    mainGroup.setAttribute('transform', `translate(${json2dPanX}, ${json2dPanY}) scale(${json2dScale})`);
                }
            }
        }
        
        // 2D Edit Mode Functions
        let is2DConnectionMode = false;
        let connection2DSource = null;
        let connection2DPreview = null;
        
        function handle2DNodeClick(node, event) {
            if (!isEditMode) {
                // View mode - just show node info
                updateNodeInfo(node);
                return;
            }
            
            // Edit mode handling
            if (event.shiftKey && !is2DConnectionMode) {
                // Start connection creation
                start2DConnection(node);
            } else if (is2DConnectionMode && connection2DSource) {
                // Complete connection
                complete2DConnection(node);
            } else {
                // Open node editor
                open2DNodeEditor(node);
            }
        }
        
        function open2DNodeEditor(node) {
            // Create a fake node object that works with the existing modal
            const nodeObj = {
                userData: {
                    id: node.id,
                    label: node.label,
                    type: node.type,
                    group: node.group,
                    notes: node.notes || '',
                    description: node.description || ''
                }
            };
            
            // Store reference to 2D node for updates
            nodeObj.is2DNode = true;
            nodeObj.node2D = node;
            
            openNodeEditor(nodeObj, false);
        }
        
        function start2DConnection(sourceNode) {
            is2DConnectionMode = true;
            connection2DSource = sourceNode;
            
            // Change cursor to indicate connection mode
            const svg = document.getElementById('json2d-canvas');
            svg.style.cursor = 'crosshair';
            
            // Add visual feedback to source node
            const sourceElement = findNodeElement(sourceNode.id);
            if (sourceElement) {
                const rect = sourceElement.querySelector('.json2d-node-rect');
                rect.setAttribute('stroke', '#ffff00');
                rect.setAttribute('stroke-width', '4');
            }
        }
        
        function complete2DConnection(targetNode) {
            if (!is2DConnectionMode || !connection2DSource || connection2DSource.id === targetNode.id) {
                cancel2DConnection();
                return;
            }
            
            // Check if connection already exists
            const existingConnection = siteData.links.find(link => 
                (link.source === connection2DSource.id && link.target === targetNode.id) ||
                (link.source === targetNode.id && link.target === connection2DSource.id)
            );
            
            if (existingConnection) {
                alert('Connection already exists between these nodes.');
                cancel2DConnection();
                return;
            }
            
            // Add new connection to siteData
            siteData.links.push({
                source: connection2DSource.id,
                target: targetNode.id
            });
            
            // Refresh the 2D visualization
            initJSON2DVisualization();
            
            cancel2DConnection();
        }
        
        function cancel2DConnection() {
            if (connection2DSource) {
                // Reset source node visual feedback
                const sourceElement = findNodeElement(connection2DSource.id);
                if (sourceElement) {
                    const rect = sourceElement.querySelector('.json2d-node-rect');
                    rect.setAttribute('stroke', '#64f4ff');
                    rect.setAttribute('stroke-width', '2');
                }
            }
            
            is2DConnectionMode = false;
            connection2DSource = null;
            
            // Reset cursor
            const svg = document.getElementById('json2d-canvas');
            svg.style.cursor = 'grab';
        }
        
        function findNodeElement(nodeId) {
            const nodeGroups = document.querySelectorAll('.json2d-node-group');
            for (const group of nodeGroups) {
                if (group.userData && group.userData.id === nodeId) {
                    return group;
                }
            }
            return null;
        }
        
        function create2DNode(x, y) {
            if (!isEditMode) return;
            
            // Convert screen coordinates to SVG coordinates
            const svg = document.getElementById('json2d-canvas');
            const rect = svg.getBoundingClientRect();
            const mainGroup = svg.querySelector('#main-group');
            
            // Account for current pan and zoom
            const svgX = (x - rect.left - json2dPanX) / json2dScale;
            const svgY = (y - rect.top - json2dPanY) / json2dScale;
            
            // Create new node data
            const nodeId = 'node-2d-' + nextNodeId++;
            const newNode = {
                id: nodeId,
                label: 'New Node',
                type: 'component',
                group: 'core',
                notes: '',
                description: '',
                x: svgX,
                y: svgY
            };
            
            // Add to siteData
            siteData.nodes.push(newNode);
            
            // Create fake node object for editor
            const nodeObj = {
                userData: newNode,
                is2DNode: true,
                node2D: newNode
            };
            
            // Open editor for new node
            openNodeEditor(nodeObj, true);
        }
        
        function update2DNodeFromEditor(node2D, updatedData) {
            // Update the 2D node data
            node2D.label = updatedData.label;
            node2D.type = updatedData.type;
            node2D.group = updatedData.group;
            node2D.notes = updatedData.notes || '';
            node2D.description = updatedData.description || '';
            
            // Update in siteData
            const nodeIndex = siteData.nodes.findIndex(n => n.id === node2D.id);
            if (nodeIndex !== -1) {
                siteData.nodes[nodeIndex] = { ...siteData.nodes[nodeIndex], ...updatedData };
            }
            
            // Refresh 2D visualization
            initJSON2DVisualization();
        }
        
        function delete2DNode(nodeId) {
            // Remove from siteData.nodes
            siteData.nodes = siteData.nodes.filter(n => n.id !== nodeId);
            
            // Remove all links connected to this node
            siteData.links = siteData.links.filter(l => l.source !== nodeId && l.target !== nodeId);
            
            // Refresh 2D visualization
            initJSON2DVisualization();
        }
        
        // Edit Mode Functions
        function toggleEditMode() {
            isEditMode = !isEditMode;
            const toggleBtn = document.getElementById('edit-mode-toggle');
            const addNodeBtn = document.getElementById('add-node');
            const saveBtn = document.getElementById('save-data');
            const loadBtn = document.getElementById('load-data');
            const exportBtn = document.getElementById('export-data');
            const canvasContainer = document.getElementById('canvas-container');
            const editControlsInfo = document.getElementById('edit-controls-info');
            
            if (isEditMode) {
                toggleBtn.textContent = 'üëÅÔ∏è View Mode';
                toggleBtn.classList.add('active');
                addNodeBtn.style.display = 'block';
                saveBtn.style.display = 'block';
                loadBtn.style.display = 'block';
                exportBtn.style.display = 'block';
                canvasContainer.classList.add('edit-mode-active');
                editControlsInfo.style.display = 'block';
                
                // Update info panel
                const infoDiv = document.querySelector('#info p:first-of-type');
                infoDiv.textContent = 'EDIT MODE: Click nodes to edit, use Add Node button or double-click empty space to create new nodes';
            } else {
                toggleBtn.textContent = 'üîß Edit Mode';
                toggleBtn.classList.remove('active');
                addNodeBtn.style.display = 'none';
                saveBtn.style.display = 'none';
                loadBtn.style.display = 'none';
                exportBtn.style.display = 'none';
                canvasContainer.classList.remove('edit-mode-active');
                editControlsInfo.style.display = 'none';
                
                // Reset info panel
                const infoDiv = document.querySelector('#info p:first-of-type');
                infoDiv.textContent = 'Interactive 3D visualization of website structure';
                
                // Close any open modals
                closeNodeEditor();
                cancelConnectionCreation();
            }
        }
        
        // Node Editor Modal Functions
        function openNodeEditor(nodeObj, isNewNode = false) {
            currentEditingNode = nodeObj;
            const modal = document.getElementById('node-editor-modal');
            const modalTitle = document.getElementById('modal-title');
            const deleteBtn = document.getElementById('delete-node-btn');
            
            // Populate form with current node data
            document.getElementById('node-label').value = nodeObj.userData.label || '';
            document.getElementById('node-type-select').value = nodeObj.userData.type || 'component';
            document.getElementById('node-group-select').value = nodeObj.userData.group || 'core';
            document.getElementById('node-notes').value = nodeObj.userData.notes || '';
            document.getElementById('node-description').value = nodeObj.userData.description || '';
            
            // Update modal title
            modalTitle.textContent = isNewNode ? 'Create New Node' : 'Edit Node';
            
            // Hide delete button for new nodes
            deleteBtn.style.display = isNewNode ? 'none' : 'block';
            
            // Show modal
            modal.style.display = 'flex';
        }
        
        function closeNodeEditor() {
            const modal = document.getElementById('node-editor-modal');
            modal.style.display = 'none';
            currentEditingNode = null;
        }
        
        function saveNodeChanges() {
            if (!currentEditingNode) return;
            
            const label = document.getElementById('node-label').value.trim();
            const type = document.getElementById('node-type-select').value;
            const group = document.getElementById('node-group-select').value;
            const notes = document.getElementById('node-notes').value.trim();
            const description = document.getElementById('node-description').value.trim();
            
            if (!label) {
                alert('Please provide a label for the node.');
                return;
            }
            
            // Check if this is a new node
            const isNewNode = !siteData.nodes.find(n => n.id === currentEditingNode.userData.id);
            
            // Update node data
            currentEditingNode.userData.label = label;
            currentEditingNode.userData.type = type;
            currentEditingNode.userData.group = group;
            currentEditingNode.userData.notes = notes;
            currentEditingNode.userData.description = description;
            
            // Handle 2D nodes differently from 3D nodes
            if (currentEditingNode.is2DNode) {
                // Update 2D node
                update2DNodeFromEditor(currentEditingNode.node2D, {
                    id: currentEditingNode.userData.id,
                    label: label,
                    type: type,
                    group: group,
                    notes: notes,
                    description: description
                });
            } else {
                // Update 3D node
                const newColor = nodeColors[type] || 0xffffff;
                currentEditingNode.material.color.setHex(newColor);
                currentEditingNode.material.emissive.setHex(newColor);
                
                // Update the label sprite
                updateNodeLabel(currentEditingNode);
                
                // Add to siteData if it's a new node
                if (isNewNode) {
                    siteData.nodes.push({
                        id: currentEditingNode.userData.id,
                        label: label,
                        type: type,
                        group: group,
                        notes: notes,
                        description: description
                    });
                } else {
                    // Update existing node in siteData
                    const nodeIndex = siteData.nodes.findIndex(n => n.id === currentEditingNode.userData.id);
                    if (nodeIndex !== -1) {
                        siteData.nodes[nodeIndex] = {
                            ...siteData.nodes[nodeIndex],
                            label: label,
                            type: type,
                            group: group,
                            notes: notes,
                            description: description
                        };
                    }
                }
            }
            
            closeNodeEditor();
        }
        
        function updateNodeLabel(nodeObj) {
            // Remove existing sprite
            const existingSprite = nodeObj.children.find(child => child.type === 'Sprite');
            if (existingSprite) {
                nodeObj.remove(existingSprite);
            }
            
            // Create new label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = 'white';
            context.font = '24px Arial';
            context.textAlign = 'center';
            context.fillText(nodeObj.userData.label, 128, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.8
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(10, 2.5, 1);
            sprite.position.y = -4;
            nodeObj.add(sprite);
        }
        
        function deleteCurrentNode() {
            if (!currentEditingNode || !confirm('Are you sure you want to delete this node? This will also remove all connections to this node.')) {
                return;
            }
            
            const nodeId = currentEditingNode.userData.id;
            
            if (currentEditingNode.is2DNode) {
                // Handle 2D node deletion
                delete2DNode(nodeId);
            } else {
                // Handle 3D node deletion
                // Remove from siteData.nodes
                siteData.nodes = siteData.nodes.filter(n => n.id !== nodeId);
                
                // Remove all links connected to this node
                siteData.links = siteData.links.filter(l => l.source !== nodeId && l.target !== nodeId);
                
                // Remove from scene
                scene.remove(currentEditingNode);
                
                // Remove from nodes array
                const nodeIndex = nodes.indexOf(currentEditingNode);
                if (nodeIndex > -1) {
                    nodes.splice(nodeIndex, 1);
                }
                
                // Remove associated links from scene
                links.forEach((link, index) => {
                    if (link.userData.source === currentEditingNode || link.userData.target === currentEditingNode) {
                        scene.remove(link);
                        links.splice(index, 1);
                    }
                });
                
                // Recreate links to update the visualization
                recreateLinks();
            }
            
            closeNodeEditor();
        }
        
        // Node Creation Functions
        function showAddNodeDialog() {
            if (!isEditMode) return;
            
            // Check if we're in 2D or 3D view
            if (currentLayout === 'json2d') {
                // Create 2D node at center of view
                const svg = document.getElementById('json2d-canvas');
                const rect = svg.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                create2DNode(centerX, centerY);
            } else {
                // Create 3D node at center of view
                const centerPosition = new THREE.Vector3(0, 0, 0);
                
                // Add some randomness to avoid overlapping with existing nodes
                centerPosition.x += (Math.random() - 0.5) * 10;
                centerPosition.y += (Math.random() - 0.5) * 10;
                centerPosition.z += (Math.random() - 0.5) * 10;
                
                createNewNode(centerPosition);
            }
        }
        
        function createNewNode(position) {
            const nodeId = 'node-' + nextNodeId++;
            const nodeGeometry = new THREE.SphereGeometry(2, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: nodeColors.component || 0x4ecdc4,
                emissive: nodeColors.component || 0x4ecdc4,
                emissiveIntensity: 0.2,
                shininess: 100
            });
            
            const nodeMesh = new THREE.Mesh(nodeGeometry, material);
            nodeMesh.userData = {
                id: nodeId,
                label: 'New Node',
                type: 'component',
                group: 'core',
                notes: '',
                description: ''
            };
            
            // Set position
            nodeMesh.position.copy(position);
            
            // Create initial label
            updateNodeLabel(nodeMesh);
            
            // Add to scene and arrays
            scene.add(nodeMesh);
            nodes.push(nodeMesh);
            
            // Open editor for the new node
            openNodeEditor(nodeMesh, true);
            
            return nodeMesh;
        }
        
        function recreateLinks() {
            // Remove all existing links from scene
            links.forEach(link => scene.remove(link));
            links.length = 0;
            
            // Recreate using the same method as createLinks
            createLinks();
        }
        
        // Connection Creation Functions
        function startConnectionCreation(sourceNode) {
            if (!isEditMode) return;
            
            isCreatingConnection = true;
            connectionSource = sourceNode;
            
            // Create preview line
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(6);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffff00, 
                transparent: true, 
                opacity: 0.8,
                linewidth: 6
            });
            
            connectionPreview = new THREE.Line(geometry, material);
            connectionPreview.userData.isPreview = true;
            scene.add(connectionPreview);
            
            // Update cursor
            document.getElementById('canvas-container').style.cursor = 'crosshair';
        }
        
        function updateConnectionPreview(mousePos) {
            if (!connectionPreview || !connectionSource) return;
            
            // Convert mouse position to world coordinates
            const vector = new THREE.Vector3(
                (mousePos.x / window.innerWidth) * 2 - 1,
                -(mousePos.y / window.innerHeight) * 2 + 1,
                0.5
            );
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            // Update preview line positions
            const positions = connectionPreview.geometry.attributes.position.array;
            positions[0] = connectionSource.position.x;
            positions[1] = connectionSource.position.y;
            positions[2] = connectionSource.position.z;
            positions[3] = pos.x;
            positions[4] = pos.y;
            positions[5] = pos.z;
            connectionPreview.geometry.attributes.position.needsUpdate = true;
        }
        
        function completeConnection(targetNode) {
            if (!isCreatingConnection || !connectionSource || connectionSource === targetNode) {
                cancelConnectionCreation();
                return;
            }
            
            // Check if connection already exists
            const existingConnection = siteData.links.find(link => 
                (link.source === connectionSource.userData.id && link.target === targetNode.userData.id) ||
                (link.source === targetNode.userData.id && link.target === connectionSource.userData.id)
            );
            
            if (existingConnection) {
                alert('Connection already exists between these nodes.');
                cancelConnectionCreation();
                return;
            }
            
            // Add new connection to siteData
            siteData.links.push({
                source: connectionSource.userData.id,
                target: targetNode.userData.id
            });
            
            // Recreate all links to include the new one
            recreateLinks();
            
            cancelConnectionCreation();
        }
        
        function cancelConnectionCreation() {
            if (connectionPreview) {
                scene.remove(connectionPreview);
                connectionPreview = null;
            }
            
            isCreatingConnection = false;
            connectionSource = null;
            document.getElementById('canvas-container').style.cursor = '';
        }
        
        // Data Persistence Functions
        function saveData() {
            try {
                const dataToSave = {
                    nodes: siteData.nodes.map(node => ({
                        ...node,
                        position: {
                            x: nodes.find(n => n.userData.id === node.id)?.position.x || 0,
                            y: nodes.find(n => n.userData.id === node.id)?.position.y || 0,
                            z: nodes.find(n => n.userData.id === node.id)?.position.z || 0
                        }
                    })),
                    links: siteData.links,
                    savedAt: new Date().toISOString(),
                    version: '1.0'
                };
                
                localStorage.setItem('agrhythm-3d-platform-data', JSON.stringify(dataToSave));
                alert('Data saved successfully to local storage!');
            } catch (error) {
                alert('Error saving data: ' + error.message);
            }
        }
        
        function loadData() {
            try {
                const savedData = localStorage.getItem('agrhythm-3d-platform-data');
                if (!savedData) {
                    alert('No saved data found.');
                    return;
                }
                
                const data = JSON.parse(savedData);
                if (!data.nodes || !data.links) {
                    alert('Invalid data format.');
                    return;
                }
                
                if (confirm('Loading will replace current data. Are you sure?')) {
                    // Clear current visualization
                    clearVisualization();
                    
                    // Load the data
                    siteData.nodes = data.nodes;
                    siteData.links = data.links;
                    
                    // Recreate visualization
                    createNodes();
                    createLinks();
                    
                    // Restore positions if available
                    if (data.nodes[0].position) {
                        data.nodes.forEach(nodeData => {
                            const node = nodes.find(n => n.userData.id === nodeData.id);
                            if (node && nodeData.position) {
                                node.position.set(nodeData.position.x, nodeData.position.y, nodeData.position.z);
                            }
                        });
                    } else {
                        // Apply current layout if no positions saved
                        applyHierarchicalLayout();
                    }
                    
                    alert('Data loaded successfully!');
                }
            } catch (error) {
                alert('Error loading data: ' + error.message);
            }
        }
        
        function exportData() {
            try {
                const dataToExport = {
                    nodes: siteData.nodes.map(node => ({
                        ...node,
                        position: {
                            x: nodes.find(n => n.userData.id === node.id)?.position.x || 0,
                            y: nodes.find(n => n.userData.id === node.id)?.position.y || 0,
                            z: nodes.find(n => n.userData.id === node.id)?.position.z || 0
                        }
                    })),
                    links: siteData.links,
                    exportedAt: new Date().toISOString(),
                    version: '1.0'
                };
                
                const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `agrhythm-platform-data-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert('Data exported successfully!');
            } catch (error) {
                alert('Error exporting data: ' + error.message);
            }
        }
        
        function clearVisualization() {
            // Remove all nodes from scene
            nodes.forEach(node => scene.remove(node));
            nodes.length = 0;
            
            // Remove all links from scene
            links.forEach(link => scene.remove(link));
            links.length = 0;
        }
        
        function setupControls() {
            // Simple orbit controls
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseButton = e.button;
                startX = e.clientX;
                startY = e.clientY;
                e.preventDefault();
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                // Update mouse position for raycasting
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                // Update connection preview if creating connection
                if (isCreatingConnection) {
                    updateConnectionPreview({ x: e.clientX, y: e.clientY });
                }
                
                if (isMouseDown) {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    if (mouseButton === 0) { // Left click - rotate
                        theta += deltaX * 0.01;
                        phi = Math.max(-Math.PI/2, Math.min(Math.PI/2, phi + deltaY * 0.01));
                        
                        camera.position.x = cameraDistance * Math.cos(phi) * Math.cos(theta);
                        camera.position.y = cameraDistance * Math.sin(phi);
                        camera.position.z = cameraDistance * Math.cos(phi) * Math.sin(theta);
                        camera.lookAt(0, 0, 0);
                    } else if (mouseButton === 2) { // Right click - pan
                        camera.position.x -= deltaX * 0.1;
                        camera.position.y += deltaY * 0.1;
                    }
                    
                    startX = e.clientX;
                    startY = e.clientY;
                }
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                cameraDistance = Math.max(20, Math.min(200, cameraDistance + e.deltaY * 0.1));
                
                camera.position.x = cameraDistance * Math.cos(phi) * Math.cos(theta);
                camera.position.y = cameraDistance * Math.sin(phi);
                camera.position.z = cameraDistance * Math.cos(phi) * Math.sin(theta);
                camera.lookAt(0, 0, 0);
                
                e.preventDefault();
            });
            
            renderer.domElement.addEventListener('click', (e) => {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(nodes);
                
                if (intersects.length > 0) {
                    const clickedNode = intersects[0].object;
                    
                    if (isCreatingConnection) {
                        // Complete connection if in connection creation mode
                        completeConnection(clickedNode);
                    } else if (isEditMode) {
                        if (e.shiftKey) {
                            // Shift + click to start connection creation
                            startConnectionCreation(clickedNode);
                        } else {
                            // Regular click in edit mode - open editor
                            openNodeEditor(clickedNode);
                        }
                    } else {
                        // View mode - show node info
                        selectedNode = clickedNode;
                        updateNodeInfo(selectedNode.userData);
                    }
                } else if (isEditMode && !isCreatingConnection) {
                    // Click on empty space in edit mode - hide node info
                    document.getElementById('node-info').style.display = 'none';
                } else {
                    // Click on empty space in view mode - hide node info
                    document.getElementById('node-info').style.display = 'none';
                }
            });
            
            renderer.domElement.addEventListener('dblclick', (e) => {
                if (isEditMode && !isCreatingConnection) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(nodes);
                    
                    if (intersects.length === 0) {
                        // Double-click on empty space - create new node
                        const vector = new THREE.Vector3(
                            (e.clientX / window.innerWidth) * 2 - 1,
                            -(e.clientY / window.innerHeight) * 2 + 1,
                            0.5
                        );
                        vector.unproject(camera);
                        
                        const dir = vector.sub(camera.position).normalize();
                        const distance = -camera.position.z / dir.z;
                        const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                        
                        createNewNode(pos);
                    }
                }
            });
            
            renderer.domElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                
                // Right-click to cancel connection creation
                if (isCreatingConnection) {
                    cancelConnectionCreation();
                }
            });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function getConnectedNodes(targetNode) {
            const connectedNodes = [];
            const targetId = targetNode.userData.id;
            
            // Find all links connected to the target node
            siteData.links.forEach(linkData => {
                let connectedNodeId = null;
                
                // Check if this link connects to our target node
                if (linkData.source === targetId) {
                    connectedNodeId = linkData.target;
                } else if (linkData.target === targetId) {
                    connectedNodeId = linkData.source;
                }
                
                // Find the actual node object
                if (connectedNodeId) {
                    const connectedNode = nodes.find(n => n.userData.id === connectedNodeId);
                    if (connectedNode && !connectedNodes.includes(connectedNode)) {
                        connectedNodes.push(connectedNode);
                    }
                }
            });
            
            return connectedNodes;
        }
        
        function updateNodeInfo(nodeData) {
            const infoDiv = document.getElementById('node-info');
            const titleEl = document.getElementById('node-title');
            const typeEl = document.getElementById('node-type');
            const connectionsEl = document.getElementById('node-connections');
            const detailsEl = document.getElementById('node-details');
            
            infoDiv.style.display = 'block';
            titleEl.textContent = nodeData.label;
            typeEl.textContent = `Type: ${nodeData.type} | Group: ${nodeData.group}`;
            
            // Count connections
            const incoming = siteData.links.filter(l => l.target === nodeData.id).length;
            const outgoing = siteData.links.filter(l => l.source === nodeData.id).length;
            connectionsEl.textContent = `Connections: ${incoming} in, ${outgoing} out`;
            
            // Show notes and description if available
            let details = '';
            if (nodeData.notes) {
                details += `Notes: ${nodeData.notes}\n`;
            }
            if (nodeData.description) {
                details += `Description: ${nodeData.description}\n`;
            }
            
            // Add default details based on type if no custom description
            if (!nodeData.description) {
                switch(nodeData.type) {
                    case 'hub':
                        details += 'Central platform hub connecting all major components';
                        break;
                    case 'component':
                        details += 'Core platform component';
                        break;
                    case 'section':
                        details += 'Dashboard section for specific functionality';
                        break;
                    case 'external':
                        details += 'External system integration via API';
                        break;
                    case 'data':
                        details += 'Data collection and storage component';
                        break;
                    default:
                        details += `${nodeData.group} component`;
                }
            }
            
            detailsEl.style.whiteSpace = 'pre-line';
            detailsEl.textContent = details;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Check for hover
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes);
            
            // Reset all nodes and links
            nodes.forEach(node => {
                node.scale.set(1, 1, 1);
                node.material.emissiveIntensity = 0.2;
                
                // Reset to original color based on node type
                const originalColor = nodeColors[node.userData.type] || 0xffffff;
                node.material.color.setHex(originalColor);
                node.material.emissive.setHex(originalColor);
            });
            
            links.forEach(link => {
                if (link.userData.isLink) {
                    // Reset all lines in the group
                    link.children.forEach(line => {
                        line.material.opacity = 0.8;
                        line.material.color.setHex(0x64f4ff);
                    });
                }
            });
            
            // Highlight hovered node and its connections
            if (intersects.length > 0) {
                hoveredNode = intersects[0].object;
                
                // Main hovered node - bright highlight
                hoveredNode.scale.set(1.3, 1.3, 1.3);
                hoveredNode.material.emissiveIntensity = 0.5;
                
                // Find and highlight connected nodes
                const connectedNodes = getConnectedNodes(hoveredNode);
                connectedNodes.forEach(node => {
                    // Connected nodes - subtle glow effect with pulsing scale
                    const pulseScale = 1.12 + Math.sin(Date.now() * 0.005) * 0.03; // Subtle pulsing
                    node.scale.set(pulseScale, pulseScale, pulseScale);
                    node.material.emissiveIntensity = 0.4;
                    
                    // Add subtle brightness increase instead of color change
                    const originalColor = nodeColors[node.userData.type] || 0xffffff;
                    const brighterColor = new THREE.Color(originalColor).multiplyScalar(1.3);
                    node.material.color.copy(brighterColor);
                });
                
                // Highlight connected links
                links.forEach(link => {
                    if (link.userData.source === hoveredNode || link.userData.target === hoveredNode) {
                        link.children.forEach(line => {
                            line.material.opacity = 1.0;
                            line.material.color.setHex(0xffff00);
                        });
                    }
                });
            }
            
            // Update link positions
            links.forEach(link => {
                if (link.userData.isLink && link.userData.source && link.userData.target) {
                    const startPos = link.userData.source.position;
                    const endPos = link.userData.target.position;
                    
                    // Update all lines in the group
                    link.children.forEach(line => {
                        const positions = line.geometry.attributes.position.array;
                        positions[0] = startPos.x;
                        positions[1] = startPos.y;
                        positions[2] = startPos.z;
                        positions[3] = endPos.x;
                        positions[4] = endPos.y;
                        positions[5] = endPos.z;
                        line.geometry.attributes.position.needsUpdate = true;
                    });
                }
            });
            
            // Note: Gentle rotation removed for structured layouts
            
            renderer.render(scene, camera);
        }
        
        // Initialize the visualization
        init();
    </script>
</body>
</html>