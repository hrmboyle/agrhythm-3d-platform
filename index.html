<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgRhythm Platform - 3D Structure Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        #info h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #64f4ff;
        }
        
        #info p {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 10px;
        }
        
        .controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .controls h3 {
            font-size: 16px;
            margin-bottom: 8px;
            color: #64f4ff;
        }
        
        .controls p {
            font-size: 12px;
            margin: 5px 0;
        }
        
        #node-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            display: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 244, 255, 0.3);
        }
        
        #node-info h3 {
            color: #64f4ff;
            margin-bottom: 10px;
        }
        
        #node-info p {
            font-size: 13px;
            margin: 5px 0;
        }
        
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .legend h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #64f4ff;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 12px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        #visualization-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
        
        #edit-controls {
            position: absolute;
            top: 80px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .edit-button {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 165, 0, 0.5);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            font-size: 12px;
        }
        
        .edit-button:hover {
            background: rgba(255, 165, 0, 0.2);
            transform: scale(1.05);
        }
        
        .edit-button.active {
            background: rgba(255, 165, 0, 0.3);
            border-color: #ffa500;
        }
        
        /* Node Editor Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: rgba(20, 20, 20, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #64f4ff;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(100, 244, 255, 0.3);
            padding-bottom: 15px;
        }
        
        .modal-header h2 {
            color: #64f4ff;
            margin: 0;
        }
        
        .close-button {
            background: none;
            border: none;
            color: #ff6b6b;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background 0.3s;
        }
        
        .close-button:hover {
            background: rgba(255, 107, 107, 0.2);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #64f4ff;
            font-weight: bold;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(100, 244, 255, 0.3);
            border-radius: 5px;
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        .form-group textarea {
            height: 80px;
            resize: vertical;
        }
        
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #64f4ff;
            box-shadow: 0 0 5px rgba(100, 244, 255, 0.5);
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid rgba(100, 244, 255, 0.3);
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .btn-primary {
            background: #64f4ff;
            color: #000;
        }
        
        .btn-primary:hover {
            background: #4dd5e8;
            transform: scale(1.05);
        }
        
        .btn-danger {
            background: #ff6b6b;
            color: white;
        }
        
        .btn-danger:hover {
            background: #ff5252;
            transform: scale(1.05);
        }
        
        .btn-secondary {
            background: rgba(100, 100, 100, 0.7);
            color: white;
        }
        
        .btn-secondary:hover {
            background: rgba(100, 100, 100, 0.9);
        }
        
        /* Edit mode indicators */
        .edit-mode-active {
            cursor: pointer !important;
        }
        
        .edit-mode-active canvas {
            cursor: crosshair !important;
        }
        
        .connection-preview {
            pointer-events: none;
        }
        
        .viz-button {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(100, 244, 255, 0.5);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .viz-button:hover {
            background: rgba(100, 244, 255, 0.2);
            transform: scale(1.05);
        }
        
        .viz-button.active {
            background: rgba(100, 244, 255, 0.3);
            border-color: #64f4ff;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="info">
        <h1>AgRhythm Platform</h1>
        <p>Interactive 3D visualization of website structure</p>
        <p>Nodes represent different pages and components. Lines show connections and data flow.</p>
        
        <div class="controls">
            <h3>Controls:</h3>
            <p>üñ±Ô∏è <strong>Left Click + Drag:</strong> Rotate</p>
            <p>üñ±Ô∏è <strong>Right Click + Drag:</strong> Pan</p>
            <p>üñ±Ô∏è <strong>Scroll:</strong> Zoom</p>
            <p>üñ±Ô∏è <strong>Hover:</strong> Highlight connections</p>
            <p>üñ±Ô∏è <strong>Click Node:</strong> Show details</p>
            <div id="edit-controls-info" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3);">
                <h4>Edit Mode:</h4>
                <p>üñòÔ∏è <strong>Click Node:</strong> Edit properties</p>
                <p>‚ûï <strong>Add Node Button:</strong> Create new node</p>
                <p>üñòÔ∏è <strong>Double-click Space:</strong> Create node at cursor</p>
                <p>üñòÔ∏è <strong>Shift + Click Node:</strong> Start connection</p>
                <p>üñòÔ∏è <strong>Right-click:</strong> Cancel connection</p>
            </div>
        </div>
    </div>
    
    <div id="visualization-toggle">
        <button class="viz-button active" onclick="switchVisualization('force')">Force Graph</button>
        <button class="viz-button" onclick="switchVisualization('hierarchical')">Hierarchical</button>
        <button class="viz-button" onclick="switchVisualization('circular')">Circular</button>
    </div>
    
    <div id="edit-controls">
        <button class="edit-button" id="edit-mode-toggle" onclick="toggleEditMode()">üîß Edit Mode</button>
        <button class="edit-button" id="add-node" onclick="showAddNodeDialog()" style="display: none;">‚ûï Add Node</button>
        <button class="edit-button" id="save-data" onclick="saveData()" style="display: none;">üíæ Save</button>
        <button class="edit-button" id="load-data" onclick="loadData()" style="display: none;">üìÅ Load</button>
        <button class="edit-button" id="export-data" onclick="exportData()" style="display: none;">üì§ Export</button>
    </div>
    
    <div class="legend">
        <h3>Node Types</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b6b;"></div>
            <span>Entry/Login Pages</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #4ecdc4;"></div>
            <span>Core Platform</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #45b7d1;"></div>
            <span>Dashboard Sections</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f7dc6f;"></div>
            <span>Operators/Specialists</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #bb8fce;"></div>
            <span>External Systems</span>
        </div>
    </div>
    
    <div id="node-info">
        <h3 id="node-title">Node Information</h3>
        <p id="node-type"></p>
        <p id="node-connections"></p>
        <p id="node-details"></p>
    </div>
    
    <!-- Node Editor Modal -->
    <div class="modal-overlay" id="node-editor-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Edit Node</h2>
                <button class="close-button" onclick="closeNodeEditor()">&times;</button>
            </div>
            
            <form id="node-editor-form">
                <div class="form-group">
                    <label for="node-label">Label:</label>
                    <input type="text" id="node-label" name="label" placeholder="Enter node label">
                </div>
                
                <div class="form-group">
                    <label for="node-type">Type:</label>
                    <select id="node-type-select" name="type">
                        <option value="entry">Entry/Login</option>
                        <option value="hub">Hub</option>
                        <option value="component">Component</option>
                        <option value="section">Section</option>
                        <option value="data">Data</option>
                        <option value="integration">Integration</option>
                        <option value="external">External</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="node-group">Group:</label>
                    <select id="node-group-select" name="group">
                        <option value="entry">Entry</option>
                        <option value="core">Core</option>
                        <option value="dashboard">Dashboard</option>
                        <option value="operators">Operators</option>
                        <option value="farmer">Farmer</option>
                        <option value="external">External</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="node-notes">Notes:</label>
                    <textarea id="node-notes" name="notes" placeholder="Add notes about this node..."></textarea>
                </div>
                
                <div class="form-group">
                    <label for="node-description">Description:</label>
                    <textarea id="node-description" name="description" placeholder="Detailed description of this node's function..."></textarea>
                </div>
            </form>
            
            <div class="button-group">
                <button type="button" class="btn btn-danger" id="delete-node-btn" onclick="deleteCurrentNode()">Delete Node</button>
                <button type="button" class="btn btn-secondary" onclick="closeNodeEditor()">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="saveNodeChanges()">Save Changes</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Website structure data
        const siteData = {
            nodes: [
                // Entry points
                { id: 'profile-edit', label: 'Profile/Edit', type: 'entry', group: 'entry' },
                { id: 'billing', label: 'Billing', type: 'entry', group: 'entry' },
                
                // Core
                { id: 'agrhythm', label: 'AgRhythm Hub', type: 'hub', group: 'core' },
                { id: 'dashboard', label: 'Dashboard', type: 'component', group: 'core' },
                { id: 'ai-chat', label: 'AI Chat', type: 'component', group: 'core' },
                { id: 'insights', label: 'Insights', type: 'component', group: 'core' },
                { id: 'collected-data', label: 'Collected Data', type: 'data', group: 'core' },
                
                // Dashboard sections
                { id: 'reports', label: 'Reports', type: 'section', group: 'dashboard' },
                { id: 'audits', label: 'Audits', type: 'section', group: 'dashboard' },
                { id: 'maps', label: 'Maps', type: 'section', group: 'dashboard' },
                { id: 'crops', label: 'Crops', type: 'section', group: 'dashboard' },
                { id: 'infrastructure', label: 'Infrastructure', type: 'section', group: 'dashboard' },
                { id: 'health-safety', label: 'Health & Safety', type: 'section', group: 'dashboard' },
                { id: 'stock', label: 'Stock', type: 'section', group: 'dashboard' },
                { id: 'tasks', label: 'Tasks/Todo', type: 'section', group: 'dashboard' },
                { id: 'finances', label: 'Finances', type: 'section', group: 'dashboard' },
                
                // Operators
                { id: 'operator-login', label: 'Operator Login', type: 'login', group: 'operators' },
                { id: 'drone-operators', label: 'Drone Operators', type: 'section', group: 'operators' },
                { id: 'other-specialists', label: 'Other Specialists', type: 'section', group: 'operators' },
                
                // Farmer
                { id: 'farmer-login', label: 'Farmer Login', type: 'login', group: 'farmer' },
                { id: 'referrals', label: 'Referrals', type: 'section', group: 'farmer' },
                { id: 'companies', label: 'Companies', type: 'component', group: 'farmer' },
                { id: 'products', label: 'Products', type: 'component', group: 'farmer' },
                
                // External
                { id: 'api-access', label: 'API Access', type: 'integration', group: 'external' },
                { id: 'cameras', label: 'Cameras', type: 'external', group: 'external' },
                { id: 'gallagher', label: 'Gallagher', type: 'external', group: 'external' },
                { id: 'iot', label: 'IOT Devices', type: 'external', group: 'external' },
                { id: 'necklaces', label: 'Necklaces', type: 'external', group: 'external' }
            ],
            links: [
                // Entry connections
                { source: 'profile-edit', target: 'billing' },
                { source: 'billing', target: 'agrhythm' },
                { source: 'profile-edit', target: 'agrhythm' },
                
                // Core connections
                { source: 'agrhythm', target: 'dashboard' },
                { source: 'dashboard', target: 'reports' },
                { source: 'dashboard', target: 'audits' },
                { source: 'dashboard', target: 'maps' },
                { source: 'dashboard', target: 'crops' },
                { source: 'dashboard', target: 'infrastructure' },
                { source: 'dashboard', target: 'health-safety' },
                { source: 'dashboard', target: 'stock' },
                { source: 'dashboard', target: 'tasks' },
                { source: 'dashboard', target: 'finances' },
                
                // AI and Data flow
                { source: 'collected-data', target: 'ai-chat' },
                { source: 'agrhythm', target: 'ai-chat' },
                { source: 'agrhythm', target: 'insights' },
                { source: 'insights', target: 'farmer-login' },
                
                // Operator flow
                { source: 'agrhythm', target: 'operator-login' },
                { source: 'operator-login', target: 'drone-operators' },
                { source: 'operator-login', target: 'other-specialists' },
                { source: 'reports', target: 'drone-operators' },
                
                // Farmer flow
                { source: 'farmer-login', target: 'referrals' },
                { source: 'referrals', target: 'companies' },
                { source: 'referrals', target: 'products' },
                
                // API connections
                { source: 'agrhythm', target: 'api-access' },
                { source: 'api-access', target: 'cameras' },
                { source: 'api-access', target: 'gallagher' },
                { source: 'api-access', target: 'iot' },
                { source: 'api-access', target: 'necklaces' },
                { source: 'api-access', target: 'collected-data' }
            ]
        };

        // Three.js setup
        let scene, camera, renderer, controls;
        let nodes = [], links = [];
        let raycaster, mouse;
        let selectedNode = null;
        let hoveredNode = null;
        let currentLayout = 'force';
        
        // Control variables
        let isMouseDown = false;
        let mouseButton = 0;
        let startX = 0, startY = 0;
        let cameraDistance = 100;
        let theta = 0, phi = 0;
        
        // Edit mode variables
        let isEditMode = false;
        let currentEditingNode = null;
        let isCreatingConnection = false;
        let connectionSource = null;
        let connectionPreview = null;
        let nextNodeId = 1000; // Start from 1000 for new nodes
        
        // Node color mapping
        const nodeColors = {
            entry: 0xff6b6b,
            hub: 0x4ecdc4,
            component: 0x4ecdc4,
            data: 0x4ecdc4,
            section: 0x45b7d1,
            login: 0xff6b6b,
            integration: 0xbb8fce,
            external: 0xbb8fce
        };
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 100, 300);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 100);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(50, 50, 50);
            scene.add(pointLight);
            
            const pointLight2 = new THREE.PointLight(0x64f4ff, 0.4);
            pointLight2.position.set(-50, -50, -50);
            scene.add(pointLight2);
            
            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Create visualization
            createNodes();
            createLinks();
            applyForceLayout();
            
            // Add mouse controls
            setupControls();
            
            // Start animation
            animate();
        }
        
        function createNodes() {
            const nodeGeometry = new THREE.SphereGeometry(2, 32, 32);
            
            siteData.nodes.forEach((nodeData, index) => {
                const material = new THREE.MeshPhongMaterial({
                    color: nodeColors[nodeData.type] || 0xffffff,
                    emissive: nodeColors[nodeData.type] || 0xffffff,
                    emissiveIntensity: 0.2,
                    shininess: 100
                });
                
                const nodeMesh = new THREE.Mesh(nodeGeometry, material);
                nodeMesh.userData = nodeData;
                
                // Create label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'white';
                context.font = '24px Arial';
                context.textAlign = 'center';
                context.fillText(nodeData.label, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.8
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(10, 2.5, 1);
                sprite.position.y = -4;
                nodeMesh.add(sprite);
                
                scene.add(nodeMesh);
                nodes.push(nodeMesh);
            });
        }
        
        function createLinks() {
            const linkMaterial = new THREE.LineBasicMaterial({ 
                color: 0x64f4ff, 
                transparent: true, 
                opacity: 0.8,
                linewidth: 8 // Much thicker
            });
            
            siteData.links.forEach(linkData => {
                const sourceNode = nodes.find(n => n.userData.id === linkData.source);
                const targetNode = nodes.find(n => n.userData.id === linkData.target);
                
                if (sourceNode && targetNode) {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(6);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    
                    // Create multiple parallel lines for thickness effect
                    const linkGroup = new THREE.Group();
                    
                    // Main line
                    const mainLine = new THREE.Line(geometry.clone(), linkMaterial.clone());
                    linkGroup.add(mainLine);
                    
                    // Add slightly offset parallel lines for thickness
                    for (let i = 0; i < 3; i++) {
                        const offsetLine = new THREE.Line(geometry.clone(), linkMaterial.clone());
                        const offset = (i + 1) * 0.02;
                        offsetLine.position.set(offset, offset * 0.5, offset * 0.3);
                        linkGroup.add(offsetLine);
                    }
                    
                    linkGroup.userData = { source: sourceNode, target: targetNode, isLink: true };
                    scene.add(linkGroup);
                    links.push(linkGroup);
                }
            });
        }
        
        function applyForceLayout() {
            // Simple force-directed layout
            const iterations = 100;
            const k = 30; // Spring constant
            const c = 0.1; // Damping
            
            // Initialize random positions
            nodes.forEach(node => {
                node.position.x = (Math.random() - 0.5) * 50;
                node.position.y = (Math.random() - 0.5) * 50;
                node.position.z = (Math.random() - 0.5) * 50;
            });
            
            // Run simulation
            for (let iter = 0; iter < iterations; iter++) {
                // Repulsive forces between all nodes
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[j].position.x - nodes[i].position.x;
                        const dy = nodes[j].position.y - nodes[i].position.y;
                        const dz = nodes[j].position.z - nodes[i].position.z;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) + 0.01;
                        const force = k * k / dist;
                        
                        nodes[i].position.x -= (dx / dist) * force * c;
                        nodes[i].position.y -= (dy / dist) * force * c;
                        nodes[i].position.z -= (dz / dist) * force * c;
                        nodes[j].position.x += (dx / dist) * force * c;
                        nodes[j].position.y += (dy / dist) * force * c;
                        nodes[j].position.z += (dz / dist) * force * c;
                    }
                }
                
                // Attractive forces for connected nodes
                links.forEach(link => {
                    const source = link.userData.source;
                    const target = link.userData.target;
                    const dx = target.position.x - source.position.x;
                    const dy = target.position.y - source.position.y;
                    const dz = target.position.z - source.position.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    const force = dist / k;
                    
                    source.position.x += (dx / dist) * force * c;
                    source.position.y += (dy / dist) * force * c;
                    source.position.z += (dz / dist) * force * c;
                    target.position.x -= (dx / dist) * force * c;
                    target.position.y -= (dy / dist) * force * c;
                    target.position.z -= (dz / dist) * force * c;
                });
            }
        }
        
        function applyHierarchicalLayout() {
            const levels = {
                'profile-edit': 0, 'billing': 0,
                'agrhythm': 1,
                'dashboard': 2, 'ai-chat': 2, 'insights': 2, 'collected-data': 2,
                'reports': 3, 'audits': 3, 'maps': 3, 'crops': 3, 'infrastructure': 3,
                'health-safety': 3, 'stock': 3, 'tasks': 3, 'finances': 3,
                'operator-login': 3, 'farmer-login': 3, 'api-access': 3,
                'drone-operators': 4, 'other-specialists': 4, 'referrals': 4,
                'cameras': 4, 'gallagher': 4, 'iot': 4, 'necklaces': 4,
                'companies': 5, 'products': 5
            };
            
            const levelCounts = {};
            Object.values(levels).forEach(level => {
                levelCounts[level] = (levelCounts[level] || 0) + 1;
            });
            
            const levelIndices = {};
            
            nodes.forEach(node => {
                const level = levels[node.userData.id] || 0;
                levelIndices[level] = (levelIndices[level] || 0) + 1;
                
                const xSpacing = 100 / (levelCounts[level] + 1);
                node.position.x = (levelIndices[level] * xSpacing) - 50;
                node.position.y = 40 - (level * 15);
                node.position.z = (Math.random() - 0.5) * 20;
            });
        }
        
        function applyCircularLayout() {
            const groupPositions = {
                'entry': { radius: 60, angle: 0 },
                'core': { radius: 20, angle: 0 },
                'dashboard': { radius: 40, angle: Math.PI },
                'operators': { radius: 50, angle: Math.PI / 2 },
                'farmer': { radius: 50, angle: -Math.PI / 2 },
                'external': { radius: 70, angle: Math.PI / 4 }
            };
            
            const groupCounts = {};
            nodes.forEach(node => {
                const group = node.userData.group;
                groupCounts[group] = (groupCounts[group] || 0) + 1;
            });
            
            const groupIndices = {};
            
            nodes.forEach(node => {
                const group = node.userData.group;
                const groupPos = groupPositions[group] || { radius: 50, angle: 0 };
                groupIndices[group] = (groupIndices[group] || 0) + 1;
                
                const angleOffset = (groupIndices[group] - 1) * (Math.PI * 2 / groupCounts[group]);
                const angle = groupPos.angle + angleOffset;
                
                node.position.x = Math.cos(angle) * groupPos.radius;
                node.position.y = Math.sin(angle) * groupPos.radius;
                node.position.z = (Math.random() - 0.5) * 30;
            });
        }
        
        function switchVisualization(type) {
            currentLayout = type;
            
            // Update button states
            document.querySelectorAll('.viz-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Apply layout
            switch(type) {
                case 'hierarchical':
                    applyHierarchicalLayout();
                    break;
                case 'circular':
                    applyCircularLayout();
                    break;
                default:
                    applyForceLayout();
            }
        }
        
        // Edit Mode Functions
        function toggleEditMode() {
            isEditMode = !isEditMode;
            const toggleBtn = document.getElementById('edit-mode-toggle');
            const addNodeBtn = document.getElementById('add-node');
            const saveBtn = document.getElementById('save-data');
            const loadBtn = document.getElementById('load-data');
            const exportBtn = document.getElementById('export-data');
            const canvasContainer = document.getElementById('canvas-container');
            const editControlsInfo = document.getElementById('edit-controls-info');
            
            if (isEditMode) {
                toggleBtn.textContent = 'üëÅÔ∏è View Mode';
                toggleBtn.classList.add('active');
                addNodeBtn.style.display = 'block';
                saveBtn.style.display = 'block';
                loadBtn.style.display = 'block';
                exportBtn.style.display = 'block';
                canvasContainer.classList.add('edit-mode-active');
                editControlsInfo.style.display = 'block';
                
                // Update info panel
                const infoDiv = document.querySelector('#info p:first-of-type');
                infoDiv.textContent = 'EDIT MODE: Click nodes to edit, use Add Node button or double-click empty space to create new nodes';
            } else {
                toggleBtn.textContent = 'üîß Edit Mode';
                toggleBtn.classList.remove('active');
                addNodeBtn.style.display = 'none';
                saveBtn.style.display = 'none';
                loadBtn.style.display = 'none';
                exportBtn.style.display = 'none';
                canvasContainer.classList.remove('edit-mode-active');
                editControlsInfo.style.display = 'none';
                
                // Reset info panel
                const infoDiv = document.querySelector('#info p:first-of-type');
                infoDiv.textContent = 'Interactive 3D visualization of website structure';
                
                // Close any open modals
                closeNodeEditor();
                cancelConnectionCreation();
            }
        }
        
        // Node Editor Modal Functions
        function openNodeEditor(nodeObj, isNewNode = false) {
            currentEditingNode = nodeObj;
            const modal = document.getElementById('node-editor-modal');
            const modalTitle = document.getElementById('modal-title');
            const deleteBtn = document.getElementById('delete-node-btn');
            
            // Populate form with current node data
            document.getElementById('node-label').value = nodeObj.userData.label || '';
            document.getElementById('node-type-select').value = nodeObj.userData.type || 'component';
            document.getElementById('node-group-select').value = nodeObj.userData.group || 'core';
            document.getElementById('node-notes').value = nodeObj.userData.notes || '';
            document.getElementById('node-description').value = nodeObj.userData.description || '';
            
            // Update modal title
            modalTitle.textContent = isNewNode ? 'Create New Node' : 'Edit Node';
            
            // Hide delete button for new nodes
            deleteBtn.style.display = isNewNode ? 'none' : 'block';
            
            // Show modal
            modal.style.display = 'flex';
        }
        
        function closeNodeEditor() {
            const modal = document.getElementById('node-editor-modal');
            modal.style.display = 'none';
            currentEditingNode = null;
        }
        
        function saveNodeChanges() {
            if (!currentEditingNode) return;
            
            const label = document.getElementById('node-label').value.trim();
            const type = document.getElementById('node-type-select').value;
            const group = document.getElementById('node-group-select').value;
            const notes = document.getElementById('node-notes').value.trim();
            const description = document.getElementById('node-description').value.trim();
            
            if (!label) {
                alert('Please provide a label for the node.');
                return;
            }
            
            // Check if this is a new node
            const isNewNode = !siteData.nodes.find(n => n.id === currentEditingNode.userData.id);
            
            // Update node data
            currentEditingNode.userData.label = label;
            currentEditingNode.userData.type = type;
            currentEditingNode.userData.group = group;
            currentEditingNode.userData.notes = notes;
            currentEditingNode.userData.description = description;
            
            // Update the material color based on type
            const newColor = nodeColors[type] || 0xffffff;
            currentEditingNode.material.color.setHex(newColor);
            currentEditingNode.material.emissive.setHex(newColor);
            
            // Update the label sprite
            updateNodeLabel(currentEditingNode);
            
            // Add to siteData if it's a new node
            if (isNewNode) {
                siteData.nodes.push({
                    id: currentEditingNode.userData.id,
                    label: label,
                    type: type,
                    group: group,
                    notes: notes,
                    description: description
                });
            } else {
                // Update existing node in siteData
                const nodeIndex = siteData.nodes.findIndex(n => n.id === currentEditingNode.userData.id);
                if (nodeIndex !== -1) {
                    siteData.nodes[nodeIndex] = {
                        ...siteData.nodes[nodeIndex],
                        label: label,
                        type: type,
                        group: group,
                        notes: notes,
                        description: description
                    };
                }
            }
            
            closeNodeEditor();
        }
        
        function updateNodeLabel(nodeObj) {
            // Remove existing sprite
            const existingSprite = nodeObj.children.find(child => child.type === 'Sprite');
            if (existingSprite) {
                nodeObj.remove(existingSprite);
            }
            
            // Create new label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = 'white';
            context.font = '24px Arial';
            context.textAlign = 'center';
            context.fillText(nodeObj.userData.label, 128, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.8
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(10, 2.5, 1);
            sprite.position.y = -4;
            nodeObj.add(sprite);
        }
        
        function deleteCurrentNode() {
            if (!currentEditingNode || !confirm('Are you sure you want to delete this node? This will also remove all connections to this node.')) {
                return;
            }
            
            const nodeId = currentEditingNode.userData.id;
            
            // Remove from siteData.nodes
            siteData.nodes = siteData.nodes.filter(n => n.id !== nodeId);
            
            // Remove all links connected to this node
            siteData.links = siteData.links.filter(l => l.source !== nodeId && l.target !== nodeId);
            
            // Remove from scene
            scene.remove(currentEditingNode);
            
            // Remove from nodes array
            const nodeIndex = nodes.indexOf(currentEditingNode);
            if (nodeIndex > -1) {
                nodes.splice(nodeIndex, 1);
            }
            
            // Remove associated links from scene
            links.forEach((link, index) => {
                if (link.userData.source === currentEditingNode || link.userData.target === currentEditingNode) {
                    scene.remove(link);
                    links.splice(index, 1);
                }
            });
            
            // Recreate links to update the visualization
            recreateLinks();
            
            closeNodeEditor();
        }
        
        // Node Creation Functions
        function showAddNodeDialog() {
            if (!isEditMode) return;
            
            // Create a new node at the center of the current view
            const centerPosition = new THREE.Vector3(0, 0, 0);
            
            // Add some randomness to avoid overlapping with existing nodes
            centerPosition.x += (Math.random() - 0.5) * 10;
            centerPosition.y += (Math.random() - 0.5) * 10;
            centerPosition.z += (Math.random() - 0.5) * 10;
            
            createNewNode(centerPosition);
        }
        
        function createNewNode(position) {
            const nodeId = 'node-' + nextNodeId++;
            const nodeGeometry = new THREE.SphereGeometry(2, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: nodeColors.component || 0x4ecdc4,
                emissive: nodeColors.component || 0x4ecdc4,
                emissiveIntensity: 0.2,
                shininess: 100
            });
            
            const nodeMesh = new THREE.Mesh(nodeGeometry, material);
            nodeMesh.userData = {
                id: nodeId,
                label: 'New Node',
                type: 'component',
                group: 'core',
                notes: '',
                description: ''
            };
            
            // Set position
            nodeMesh.position.copy(position);
            
            // Create initial label
            updateNodeLabel(nodeMesh);
            
            // Add to scene and arrays
            scene.add(nodeMesh);
            nodes.push(nodeMesh);
            
            // Open editor for the new node
            openNodeEditor(nodeMesh, true);
            
            return nodeMesh;
        }
        
        function recreateLinks() {
            // Remove all existing links from scene
            links.forEach(link => scene.remove(link));
            links.length = 0;
            
            // Recreate using the same method as createLinks
            createLinks();
        }
        
        // Connection Creation Functions
        function startConnectionCreation(sourceNode) {
            if (!isEditMode) return;
            
            isCreatingConnection = true;
            connectionSource = sourceNode;
            
            // Create preview line
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(6);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffff00, 
                transparent: true, 
                opacity: 0.8,
                linewidth: 6
            });
            
            connectionPreview = new THREE.Line(geometry, material);
            connectionPreview.userData.isPreview = true;
            scene.add(connectionPreview);
            
            // Update cursor
            document.getElementById('canvas-container').style.cursor = 'crosshair';
        }
        
        function updateConnectionPreview(mousePos) {
            if (!connectionPreview || !connectionSource) return;
            
            // Convert mouse position to world coordinates
            const vector = new THREE.Vector3(
                (mousePos.x / window.innerWidth) * 2 - 1,
                -(mousePos.y / window.innerHeight) * 2 + 1,
                0.5
            );
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            // Update preview line positions
            const positions = connectionPreview.geometry.attributes.position.array;
            positions[0] = connectionSource.position.x;
            positions[1] = connectionSource.position.y;
            positions[2] = connectionSource.position.z;
            positions[3] = pos.x;
            positions[4] = pos.y;
            positions[5] = pos.z;
            connectionPreview.geometry.attributes.position.needsUpdate = true;
        }
        
        function completeConnection(targetNode) {
            if (!isCreatingConnection || !connectionSource || connectionSource === targetNode) {
                cancelConnectionCreation();
                return;
            }
            
            // Check if connection already exists
            const existingConnection = siteData.links.find(link => 
                (link.source === connectionSource.userData.id && link.target === targetNode.userData.id) ||
                (link.source === targetNode.userData.id && link.target === connectionSource.userData.id)
            );
            
            if (existingConnection) {
                alert('Connection already exists between these nodes.');
                cancelConnectionCreation();
                return;
            }
            
            // Add new connection to siteData
            siteData.links.push({
                source: connectionSource.userData.id,
                target: targetNode.userData.id
            });
            
            // Recreate all links to include the new one
            recreateLinks();
            
            cancelConnectionCreation();
        }
        
        function cancelConnectionCreation() {
            if (connectionPreview) {
                scene.remove(connectionPreview);
                connectionPreview = null;
            }
            
            isCreatingConnection = false;
            connectionSource = null;
            document.getElementById('canvas-container').style.cursor = '';
        }
        
        // Data Persistence Functions
        function saveData() {
            try {
                const dataToSave = {
                    nodes: siteData.nodes.map(node => ({
                        ...node,
                        position: {
                            x: nodes.find(n => n.userData.id === node.id)?.position.x || 0,
                            y: nodes.find(n => n.userData.id === node.id)?.position.y || 0,
                            z: nodes.find(n => n.userData.id === node.id)?.position.z || 0
                        }
                    })),
                    links: siteData.links,
                    savedAt: new Date().toISOString(),
                    version: '1.0'
                };
                
                localStorage.setItem('agrhythm-3d-platform-data', JSON.stringify(dataToSave));
                alert('Data saved successfully to local storage!');
            } catch (error) {
                alert('Error saving data: ' + error.message);
            }
        }
        
        function loadData() {
            try {
                const savedData = localStorage.getItem('agrhythm-3d-platform-data');
                if (!savedData) {
                    alert('No saved data found.');
                    return;
                }
                
                const data = JSON.parse(savedData);
                if (!data.nodes || !data.links) {
                    alert('Invalid data format.');
                    return;
                }
                
                if (confirm('Loading will replace current data. Are you sure?')) {
                    // Clear current visualization
                    clearVisualization();
                    
                    // Load the data
                    siteData.nodes = data.nodes;
                    siteData.links = data.links;
                    
                    // Recreate visualization
                    createNodes();
                    createLinks();
                    
                    // Restore positions if available
                    if (data.nodes[0].position) {
                        data.nodes.forEach(nodeData => {
                            const node = nodes.find(n => n.userData.id === nodeData.id);
                            if (node && nodeData.position) {
                                node.position.set(nodeData.position.x, nodeData.position.y, nodeData.position.z);
                            }
                        });
                    } else {
                        // Apply current layout if no positions saved
                        applyForceLayout();
                    }
                    
                    alert('Data loaded successfully!');
                }
            } catch (error) {
                alert('Error loading data: ' + error.message);
            }
        }
        
        function exportData() {
            try {
                const dataToExport = {
                    nodes: siteData.nodes.map(node => ({
                        ...node,
                        position: {
                            x: nodes.find(n => n.userData.id === node.id)?.position.x || 0,
                            y: nodes.find(n => n.userData.id === node.id)?.position.y || 0,
                            z: nodes.find(n => n.userData.id === node.id)?.position.z || 0
                        }
                    })),
                    links: siteData.links,
                    exportedAt: new Date().toISOString(),
                    version: '1.0'
                };
                
                const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `agrhythm-platform-data-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert('Data exported successfully!');
            } catch (error) {
                alert('Error exporting data: ' + error.message);
            }
        }
        
        function clearVisualization() {
            // Remove all nodes from scene
            nodes.forEach(node => scene.remove(node));
            nodes.length = 0;
            
            // Remove all links from scene
            links.forEach(link => scene.remove(link));
            links.length = 0;
        }
        
        function setupControls() {
            // Simple orbit controls
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseButton = e.button;
                startX = e.clientX;
                startY = e.clientY;
                e.preventDefault();
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                // Update mouse position for raycasting
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                // Update connection preview if creating connection
                if (isCreatingConnection) {
                    updateConnectionPreview({ x: e.clientX, y: e.clientY });
                }
                
                if (isMouseDown) {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    if (mouseButton === 0) { // Left click - rotate
                        theta += deltaX * 0.01;
                        phi = Math.max(-Math.PI/2, Math.min(Math.PI/2, phi + deltaY * 0.01));
                        
                        camera.position.x = cameraDistance * Math.cos(phi) * Math.cos(theta);
                        camera.position.y = cameraDistance * Math.sin(phi);
                        camera.position.z = cameraDistance * Math.cos(phi) * Math.sin(theta);
                        camera.lookAt(0, 0, 0);
                    } else if (mouseButton === 2) { // Right click - pan
                        camera.position.x -= deltaX * 0.1;
                        camera.position.y += deltaY * 0.1;
                    }
                    
                    startX = e.clientX;
                    startY = e.clientY;
                }
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                cameraDistance = Math.max(20, Math.min(200, cameraDistance + e.deltaY * 0.1));
                
                camera.position.x = cameraDistance * Math.cos(phi) * Math.cos(theta);
                camera.position.y = cameraDistance * Math.sin(phi);
                camera.position.z = cameraDistance * Math.cos(phi) * Math.sin(theta);
                camera.lookAt(0, 0, 0);
                
                e.preventDefault();
            });
            
            renderer.domElement.addEventListener('click', (e) => {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(nodes);
                
                if (intersects.length > 0) {
                    const clickedNode = intersects[0].object;
                    
                    if (isCreatingConnection) {
                        // Complete connection if in connection creation mode
                        completeConnection(clickedNode);
                    } else if (isEditMode) {
                        if (e.shiftKey) {
                            // Shift + click to start connection creation
                            startConnectionCreation(clickedNode);
                        } else {
                            // Regular click in edit mode - open editor
                            openNodeEditor(clickedNode);
                        }
                    } else {
                        // View mode - show node info
                        selectedNode = clickedNode;
                        updateNodeInfo(selectedNode.userData);
                    }
                } else if (isEditMode && !isCreatingConnection) {
                    // Click on empty space in edit mode - hide node info
                    document.getElementById('node-info').style.display = 'none';
                } else {
                    // Click on empty space in view mode - hide node info
                    document.getElementById('node-info').style.display = 'none';
                }
            });
            
            renderer.domElement.addEventListener('dblclick', (e) => {
                if (isEditMode && !isCreatingConnection) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(nodes);
                    
                    if (intersects.length === 0) {
                        // Double-click on empty space - create new node
                        const vector = new THREE.Vector3(
                            (e.clientX / window.innerWidth) * 2 - 1,
                            -(e.clientY / window.innerHeight) * 2 + 1,
                            0.5
                        );
                        vector.unproject(camera);
                        
                        const dir = vector.sub(camera.position).normalize();
                        const distance = -camera.position.z / dir.z;
                        const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                        
                        createNewNode(pos);
                    }
                }
            });
            
            renderer.domElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                
                // Right-click to cancel connection creation
                if (isCreatingConnection) {
                    cancelConnectionCreation();
                }
            });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function getConnectedNodes(targetNode) {
            const connectedNodes = [];
            const targetId = targetNode.userData.id;
            
            // Find all links connected to the target node
            siteData.links.forEach(linkData => {
                let connectedNodeId = null;
                
                // Check if this link connects to our target node
                if (linkData.source === targetId) {
                    connectedNodeId = linkData.target;
                } else if (linkData.target === targetId) {
                    connectedNodeId = linkData.source;
                }
                
                // Find the actual node object
                if (connectedNodeId) {
                    const connectedNode = nodes.find(n => n.userData.id === connectedNodeId);
                    if (connectedNode && !connectedNodes.includes(connectedNode)) {
                        connectedNodes.push(connectedNode);
                    }
                }
            });
            
            return connectedNodes;
        }
        
        function updateNodeInfo(nodeData) {
            const infoDiv = document.getElementById('node-info');
            const titleEl = document.getElementById('node-title');
            const typeEl = document.getElementById('node-type');
            const connectionsEl = document.getElementById('node-connections');
            const detailsEl = document.getElementById('node-details');
            
            infoDiv.style.display = 'block';
            titleEl.textContent = nodeData.label;
            typeEl.textContent = `Type: ${nodeData.type} | Group: ${nodeData.group}`;
            
            // Count connections
            const incoming = siteData.links.filter(l => l.target === nodeData.id).length;
            const outgoing = siteData.links.filter(l => l.source === nodeData.id).length;
            connectionsEl.textContent = `Connections: ${incoming} in, ${outgoing} out`;
            
            // Show notes and description if available
            let details = '';
            if (nodeData.notes) {
                details += `Notes: ${nodeData.notes}\n`;
            }
            if (nodeData.description) {
                details += `Description: ${nodeData.description}\n`;
            }
            
            // Add default details based on type if no custom description
            if (!nodeData.description) {
                switch(nodeData.type) {
                    case 'hub':
                        details += 'Central platform hub connecting all major components';
                        break;
                    case 'component':
                        details += 'Core platform component';
                        break;
                    case 'section':
                        details += 'Dashboard section for specific functionality';
                        break;
                    case 'external':
                        details += 'External system integration via API';
                        break;
                    case 'data':
                        details += 'Data collection and storage component';
                        break;
                    default:
                        details += `${nodeData.group} component`;
                }
            }
            
            detailsEl.style.whiteSpace = 'pre-line';
            detailsEl.textContent = details;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Check for hover
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes);
            
            // Reset all nodes and links
            nodes.forEach(node => {
                node.scale.set(1, 1, 1);
                node.material.emissiveIntensity = 0.2;
                
                // Reset to original color based on node type
                const originalColor = nodeColors[node.userData.type] || 0xffffff;
                node.material.color.setHex(originalColor);
                node.material.emissive.setHex(originalColor);
            });
            
            links.forEach(link => {
                if (link.userData.isLink) {
                    // Reset all lines in the group
                    link.children.forEach(line => {
                        line.material.opacity = 0.8;
                        line.material.color.setHex(0x64f4ff);
                    });
                }
            });
            
            // Highlight hovered node and its connections
            if (intersects.length > 0) {
                hoveredNode = intersects[0].object;
                
                // Main hovered node - bright highlight
                hoveredNode.scale.set(1.3, 1.3, 1.3);
                hoveredNode.material.emissiveIntensity = 0.5;
                
                // Find and highlight connected nodes
                const connectedNodes = getConnectedNodes(hoveredNode);
                connectedNodes.forEach(node => {
                    // Connected nodes - subtle glow effect with pulsing scale
                    const pulseScale = 1.12 + Math.sin(Date.now() * 0.005) * 0.03; // Subtle pulsing
                    node.scale.set(pulseScale, pulseScale, pulseScale);
                    node.material.emissiveIntensity = 0.4;
                    
                    // Add subtle brightness increase instead of color change
                    const originalColor = nodeColors[node.userData.type] || 0xffffff;
                    const brighterColor = new THREE.Color(originalColor).multiplyScalar(1.3);
                    node.material.color.copy(brighterColor);
                });
                
                // Highlight connected links
                links.forEach(link => {
                    if (link.userData.source === hoveredNode || link.userData.target === hoveredNode) {
                        link.children.forEach(line => {
                            line.material.opacity = 1.0;
                            line.material.color.setHex(0xffff00);
                        });
                    }
                });
            }
            
            // Update link positions
            links.forEach(link => {
                if (link.userData.isLink && link.userData.source && link.userData.target) {
                    const startPos = link.userData.source.position;
                    const endPos = link.userData.target.position;
                    
                    // Update all lines in the group
                    link.children.forEach(line => {
                        const positions = line.geometry.attributes.position.array;
                        positions[0] = startPos.x;
                        positions[1] = startPos.y;
                        positions[2] = startPos.z;
                        positions[3] = endPos.x;
                        positions[4] = endPos.y;
                        positions[5] = endPos.z;
                        line.geometry.attributes.position.needsUpdate = true;
                    });
                }
            });
            
            // Gentle rotation for visual interest
            if (!isMouseDown && currentLayout === 'force') {
                scene.rotation.y += 0.001;
            }
            
            renderer.render(scene, camera);
        }
        
        // Initialize the visualization
        init();
    </script>
</body>
</html>